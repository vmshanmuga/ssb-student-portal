/**
 * Exam Attempt Page
 * Main exam interface with timer, question navigation, and proctoring
 * Apple-inspired sleek design with comprehensive proctoring features
 */

import React, { useState, useEffect, useRef, useCallback } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import {
  Clock,
  ChevronLeft,
  ChevronRight,
  Flag,
  AlertTriangle,
  CheckCircle,
  XCircle,
  Eye,
  EyeOff,
  Save,
  Send,
  Maximize,
  Video,
  Monitor
} from 'lucide-react';
import {
  getExamById,
  startExamAttempt,
  saveAnswer as saveAnswerAPI,
  logViolation as logViolationAPI,
  uploadScreenshot as uploadScreenshotAPI,
  submitExam as submitExamAPI,
  type Exam,
  type Question
} from '../services/examApi';
import { useAuth } from '../contexts/AuthContext';

interface Answer {
  questionId: string;
  answer: string;
  flagged: boolean;
}

interface ProctoringLog {
  timestamp: string;
  type: 'tab_switch' | 'window_blur' | 'fullscreen_exit' | 'copy' | 'paste' | 'right_click' | 'screenshot';
  details: string;
}

const ExamAttempt: React.FC = () => {
  const navigate = useNavigate();
  const { examId } = useParams<{ examId: string }>();
  const { student } = useAuth();

  // Exam State
  const [exam, setExam] = useState<Exam | null>(null);
  const [loading, setLoading] = useState(true);
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [answers, setAnswers] = useState<Map<string, Answer>>(new Map());
  const [timeRemaining, setTimeRemaining] = useState(0); // in seconds
  const [examStartTime, setExamStartTime] = useState<Date | null>(null);
  const [attemptId, setAttemptId] = useState<string | null>(null);

  // Proctoring State
  const [violations, setViolations] = useState<ProctoringLog[]>([]);
  const [webcamActive, setWebcamActive] = useState(false);
  const [screenShareActive, setScreenShareActive] = useState(false);
  const [violationCount, setViolationCount] = useState(0);

  // UI State
  const [showWarning, setShowWarning] = useState(false);
  const [warningMessage, setWarningMessage] = useState('');
  const [showSubmitConfirm, setShowSubmitConfirm] = useState(false);
  const [submitting, setSubmitting] = useState(false);

  // Refs
  const videoRef = useRef<HTMLVideoElement>(null);
  const timerIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const screenshotIntervalRef = useRef<NodeJS.Timeout | null>(null);

  // Load Exam
  useEffect(() => {
    if (examId) {
      loadExam();
    }
  }, [examId]);

  const loadExam = async () => {
    try {
      setLoading(true);
      const response = await getExamById(examId!);
      if (response.success && response.data) {
        const examData = response.data;
        const normalized = {
          ...examData,
          examId: examData['Exam ID'] || examData.examId,
          examTitle: examData['Exam Title'] || examData.examTitle,
          duration: examData['Duration (minutes)'] || examData.duration,
          questions: examData.questions || [],
          settings: examData.settings
        };
        setExam(normalized);
        setTimeRemaining((normalized.duration || 60) * 60); // Convert minutes to seconds
        setExamStartTime(new Date());

        // Initialize answers map
        const initialAnswers = new Map<string, Answer>();
        (normalized.questions || []).forEach((q: any) => {
          initialAnswers.set(q.questionId || '', {
            questionId: q.questionId || '',
            answer: '',
            flagged: false
          });
        });
        setAnswers(initialAnswers);

        // Start exam attempt in backend
        const attemptResponse = await startExamAttempt(
          normalized.examId,
          student?.name || student?.email || 'Student'
        );

        if (attemptResponse.success) {
          const attemptIdValue = attemptResponse.data?.attemptId || attemptResponse.attemptId;
          if (!attemptIdValue) {
            throw new Error('No attempt ID returned from backend');
          }
          setAttemptId(attemptIdValue);

          // Check if practice exam - skip proctoring
          const isPractice = normalized['Is Practice'] === 'Yes' || normalized.isPractice === true;
          if (!isPractice) {
            // Start proctoring only for regular exams
            startProctoring(normalized);
          }
        } else {
          throw new Error(attemptResponse.message || 'Failed to start exam attempt');
        }
      }
    } catch (err) {
      console.error('Error loading exam:', err);
      alert('Failed to start exam. Please try again.');
      navigate('/exams');
    } finally {
      setLoading(false);
    }
  };

  // Timer
  useEffect(() => {
    if (exam && timeRemaining > 0) {
      timerIntervalRef.current = setInterval(() => {
        setTimeRemaining(prev => {
          if (prev <= 1) {
            handleAutoSubmit();
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
    }

    return () => {
      if (timerIntervalRef.current) {
        clearInterval(timerIntervalRef.current);
      }
    };
  }, [exam, timeRemaining]);

  // Proctoring Setup
  const startProctoring = (examData: Exam) => {
    const settings = examData.settings?.proctoring;

    // Start webcam
    if (settings?.webcamRequired && (window as any).examMediaStream) {
      const stream = (window as any).examMediaStream;
      if (videoRef.current) {
        videoRef.current.srcObject = stream;
        setWebcamActive(true);
      }
    }

    // Start screen share monitoring
    if (settings?.enforceScreensharing && (window as any).examScreenStream) {
      setScreenShareActive(true);
    }

    // Setup event listeners for proctoring
    setupProctoringEventListeners(examData);

    // Start periodic screenshots
    if (settings?.webcamRequired) {
      screenshotIntervalRef.current = setInterval(() => {
        captureScreenshot();
      }, 30000); // Every 30 seconds
    }
  };

  const setupProctoringEventListeners = (examData: Exam) => {
    const settings = examData.settings?.proctoring;

    // Fullscreen exit detection
    const handleFullscreenChange = () => {
      if (!document.fullscreenElement && settings?.fullscreenMandatory) {
        logViolation('fullscreen_exit', 'User exited fullscreen mode');
        showViolationWarning('Please return to fullscreen mode');
      }
    };

    // Tab/Window switching detection
    const handleVisibilityChange = () => {
      if (document.hidden && !settings?.allowTabSwitching) {
        logViolation('tab_switch', 'User switched tabs or minimized window');
        showViolationWarning('Tab switching is not allowed during the exam');
      }
    };

    const handleWindowBlur = () => {
      if (!settings?.allowWindowSwitching) {
        logViolation('window_blur', 'User switched windows');
        showViolationWarning('Window switching is not allowed');
      }
    };

    // Copy/Paste detection
    const handleCopy = (e: ClipboardEvent) => {
      if (!settings?.allowCopyPaste) {
        e.preventDefault();
        logViolation('copy', 'User attempted to copy content');
        showViolationWarning('Copying is not allowed during the exam');
      }
    };

    const handlePaste = (e: ClipboardEvent) => {
      if (!settings?.allowCopyPaste) {
        e.preventDefault();
        logViolation('paste', 'User attempted to paste content');
        showViolationWarning('Pasting is not allowed during the exam');
      }
    };

    // Right click detection
    const handleContextMenu = (e: MouseEvent) => {
      if (!settings?.allowRightClick) {
        e.preventDefault();
        logViolation('right_click', 'User attempted right click');
        showViolationWarning('Right click is disabled during the exam');
      }
    };

    // Attach listeners
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('visibilitychange', handleVisibilityChange);
    window.addEventListener('blur', handleWindowBlur);
    document.addEventListener('copy', handleCopy);
    document.addEventListener('paste', handlePaste);
    document.addEventListener('contextmenu', handleContextMenu);

    // Cleanup
    return () => {
      document.removeEventListener('fullscreenchange', handleFullscreenChange);
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      window.removeEventListener('blur', handleWindowBlur);
      document.removeEventListener('copy', handleCopy);
      document.removeEventListener('paste', handlePaste);
      document.removeEventListener('contextmenu', handleContextMenu);

      if (screenshotIntervalRef.current) {
        clearInterval(screenshotIntervalRef.current);
      }
    };
  };

  const logViolation = async (type: ProctoringLog['type'], details: string) => {
    const log: ProctoringLog = {
      timestamp: new Date().toISOString(),
      type,
      details
    };

    setViolations(prev => [...prev, log]);
    setViolationCount(prev => prev + 1);

    // Check if max violations exceeded
    const maxViolations = exam?.settings?.proctoring?.maxViolationsBeforeAction || 5;
    if (violationCount + 1 >= maxViolations) {
      if (exam?.settings?.proctoring?.disqualifyOnViolation) {
        handleDisqualification();
      }
    }

    // Log to backend
    if (attemptId && examId) {
      try {
        await logViolationAPI(attemptId, examId, type, details);
      } catch (err) {
        console.error('Failed to log violation:', err);
      }
    }
  };

  const showViolationWarning = (message: string) => {
    setWarningMessage(message);
    setShowWarning(true);

    if (exam?.settings?.proctoring?.beepAlerts) {
      playBeepSound();
    }

    setTimeout(() => {
      setShowWarning(false);
    }, 5000);
  };

  const playBeepSound = () => {
    const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBjKF0fPTgjMGHm7A7+OZUR4OVLDp66hVFApNpeDwvWwhBjeQ1vLNeSsF');
    audio.volume = 0.3;
    audio.play().catch(e => console.log('Beep audio error:', e));
  };

  const captureScreenshot = async () => {
    if (videoRef.current && webcamActive && attemptId && examId) {
      const canvas = document.createElement('canvas');
      canvas.width = videoRef.current.videoWidth;
      canvas.height = videoRef.current.videoHeight;
      const ctx = canvas.getContext('2d');

      if (ctx) {
        ctx.drawImage(videoRef.current, 0, 0);
        const screenshot = canvas.toDataURL('image/jpeg', 0.8);

        // Upload to backend
        try {
          await uploadScreenshotAPI(attemptId, examId, screenshot, 'periodic');
          console.log('Screenshot uploaded at', new Date().toISOString());
        } catch (err) {
          console.error('Failed to upload screenshot:', err);
        }
      }
    }
  };

  const handleDisqualification = () => {
    alert('You have been disqualified due to multiple violations.');
    handleSubmit(true);
  };

  // Navigation
  const handlePreviousQuestion = () => {
    if (currentQuestionIndex > 0) {
      setCurrentQuestionIndex(prev => prev - 1);
    }
  };

  const handleNextQuestion = () => {
    if (currentQuestionIndex < (exam?.questions?.length || 0) - 1) {
      setCurrentQuestionIndex(prev => prev + 1);
    }
  };

  const handleJumpToQuestion = (index: number) => {
    setCurrentQuestionIndex(index);
  };

  // Answer Handling
  const handleAnswerChange = async (questionId: string, answer: string) => {
    setAnswers(prev => {
      const newAnswers = new Map(prev);
      const existing = newAnswers.get(questionId);
      newAnswers.set(questionId, {
        ...existing!,
        answer
      });
      return newAnswers;
    });

    // Auto-save answer to backend
    if (attemptId && examId) {
      try {
        await saveAnswerAPI(attemptId, examId, questionId, answer);
      } catch (err) {
        console.error('Failed to save answer:', err);
      }
    }
  };

  const handleToggleFlag = (questionId: string) => {
    setAnswers(prev => {
      const newAnswers = new Map(prev);
      const existing = newAnswers.get(questionId);
      newAnswers.set(questionId, {
        ...existing!,
        flagged: !existing!.flagged
      });
      return newAnswers;
    });
  };

  // Submit
  const handleAutoSubmit = () => {
    if (exam?.settings?.autoSubmitOnTimeUp) {
      handleSubmit(true);
    } else {
      showViolationWarning('Time is up! Please submit your exam.');
    }
  };

  const handleSubmit = async (forced: boolean = false) => {
    if (!forced) {
      setShowSubmitConfirm(true);
      return;
    }

    if (!attemptId || !examId) {
      alert('Exam session error. Please try again.');
      return;
    }

    setSubmitting(true);

    try {
      // Prepare submission data
      const timeSpent = ((exam?.duration || 0) * 60) - timeRemaining;
      const answersArray = Array.from(answers.values());

      // Submit to backend
      const response = await submitExamAPI(
        attemptId,
        examId,
        answersArray,
        violations,
        timeSpent
      );

      if (!response.success) {
        throw new Error(response.message || 'Failed to submit exam');
      }

      // Clean up
      if (videoRef.current?.srcObject) {
        const stream = videoRef.current.srcObject as MediaStream;
        stream.getTracks().forEach(track => track.stop());
      }

      if ((window as any).examScreenStream) {
        const stream = (window as any).examScreenStream as MediaStream;
        stream.getTracks().forEach(track => track.stop());
      }

      // Exit fullscreen
      if (document.fullscreenElement) {
        document.exitFullscreen();
      }

      // Navigate to results page
      setTimeout(() => {
        navigate(`/exams/result/${attemptId}`);
      }, 1000);

    } catch (error: any) {
      console.error('Submission error:', error);
      alert(error.message || 'Failed to submit exam. Please try again.');
    } finally {
      setSubmitting(false);
    }
  };

  // Format time
  const formatTime = (seconds: number): string => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;

    if (hours > 0) {
      return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    return `${minutes}:${secs.toString().padStart(2, '0')}`;
  };

  const getTimeColor = (): string => {
    if (timeRemaining < 300) return 'text-red-600 dark:text-red-400'; // < 5 minutes
    if (timeRemaining < 600) return 'text-orange-600 dark:text-orange-400'; // < 10 minutes
    return 'text-gray-900 dark:text-white';
  };

  if (loading) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-green-600"></div>
      </div>
    );
  }

  if (!exam || !exam.questions || exam.questions.length === 0) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="text-center text-white">
          <AlertTriangle className="w-16 h-16 mx-auto mb-4" />
          <h3 className="text-xl font-semibold mb-2">Exam not available</h3>
          <button
            onClick={() => navigate('/exams')}
            className="mt-4 px-6 py-2.5 bg-green-600 hover:bg-green-700 rounded-xl transition-all"
          >
            Back to Exams
          </button>
        </div>
      </div>
    );
  }

  const currentQuestion = exam.questions[currentQuestionIndex] as any;
  const currentAnswer = answers.get(currentQuestion.questionId || '');
  const answeredCount = Array.from(answers.values()).filter(a => a.answer).length;
  const flaggedCount = Array.from(answers.values()).filter(a => a.flagged).length;

  return (
    <div className="min-h-screen bg-gray-900 text-white flex flex-col">
      {/* Top Bar */}
      <div className="bg-gray-800 border-b border-gray-700 px-6 py-4">
        <div className="max-w-7xl mx-auto flex items-center justify-between">
          {/* Exam Title */}
          <div>
            <h1 className="text-xl font-bold">{exam.examTitle}</h1>
            <p className="text-sm text-gray-400">
              Question {currentQuestionIndex + 1} of {exam.questions.length}
            </p>
          </div>

          {/* Timer */}
          <div className={`flex items-center gap-2 px-4 py-2 rounded-xl ${
            timeRemaining < 300 ? 'bg-red-900/30 border-red-800' : 'bg-gray-700'
          } border`}>
            <Clock className="w-5 h-5" />
            <span className={`text-2xl font-mono font-bold ${getTimeColor()}`}>
              {formatTime(timeRemaining)}
            </span>
          </div>

          {/* Submit Button */}
          <button
            onClick={() => handleSubmit(false)}
            className="px-6 py-2.5 bg-green-600 hover:bg-green-700 rounded-xl font-semibold transition-all flex items-center gap-2"
          >
            <Send className="w-4 h-4" />
            Submit Exam
          </button>
        </div>
      </div>

      {/* Main Content */}
      <div className="flex-1 flex overflow-hidden">
        {/* Question Panel */}
        <div className="flex-1 overflow-y-auto p-6">
          <div className="max-w-4xl mx-auto">
            {/* Question Card */}
            <div className="bg-gray-800 rounded-2xl border border-gray-700 p-8">
              {/* Question Header */}
              <div className="flex items-start justify-between mb-6">
                <div>
                  <div className="flex items-center gap-3 mb-2">
                    <span className="text-green-400 font-semibold">
                      Question {currentQuestionIndex + 1}
                    </span>
                    <span className="px-2.5 py-0.5 rounded-full text-xs font-medium bg-blue-900/30 text-blue-300">
                      {currentQuestion.questionType}
                    </span>
                    <span className="text-sm text-gray-400">
                      {currentQuestion.marks} marks
                    </span>
                  </div>
                </div>
                <button
                  onClick={() => handleToggleFlag(currentQuestion.questionId)}
                  className={`p-2 rounded-lg transition-colors ${
                    currentAnswer?.flagged
                      ? 'bg-orange-900/30 text-orange-400'
                      : 'bg-gray-700 text-gray-400 hover:text-orange-400'
                  }`}
                >
                  <Flag className="w-5 h-5" fill={currentAnswer?.flagged ? 'currentColor' : 'none'} />
                </button>
              </div>

              {/* Question Text */}
              <div
                className="prose prose-invert max-w-none mb-6 text-lg"
                dangerouslySetInnerHTML={{ __html: currentQuestion.questionText }}
              />

              {/* Question Image */}
              {currentQuestion.questionImageUrl && (
                <div className="mb-6">
                  <img
                    src={currentQuestion.questionImageUrl}
                    alt="Question"
                    className="max-w-lg rounded-lg border border-gray-700"
                  />
                </div>
              )}

              {/* Answer Options - MCQ */}
              {(currentQuestion.questionType === 'MCQ' || currentQuestion.questionType === 'MCQ_IMAGE') && (
                <div className="space-y-3">
                  {['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'].map((option) => {
                    const optionKey = `option${option}` as keyof typeof currentQuestion;
                    const optionValue = currentQuestion[optionKey];
                    if (!optionValue) return null;

                    const isSelected = currentAnswer?.answer === option;

                    return (
                      <button
                        key={option}
                        onClick={() => handleAnswerChange(currentQuestion.questionId, option)}
                        className={`w-full p-4 rounded-xl border-2 text-left transition-all ${
                          isSelected
                            ? 'border-green-500 bg-green-900/20'
                            : 'border-gray-700 bg-gray-700/30 hover:border-gray-600'
                        }`}
                      >
                        <div className="flex items-center gap-3">
                          <div className={`w-6 h-6 rounded-full border-2 flex items-center justify-center ${
                            isSelected ? 'border-green-500 bg-green-500' : 'border-gray-600'
                          }`}>
                            {isSelected && <CheckCircle className="w-4 h-4 text-white" />}
                          </div>
                          <span className="font-medium">{option}.</span>
                          <span>{optionValue}</span>
                        </div>
                      </button>
                    );
                  })}
                </div>
              )}

              {/* Answer Input - Short Answer */}
              {currentQuestion.questionType === 'SHORT_ANSWER' && (
                <div>
                  <label className="block text-sm font-medium text-gray-400 mb-2">
                    Your Answer
                  </label>
                  <input
                    type="text"
                    value={currentAnswer?.answer || ''}
                    onChange={(e) => handleAnswerChange(currentQuestion.questionId, e.target.value)}
                    placeholder="Type your answer here..."
                    className="w-full px-4 py-3 rounded-xl bg-gray-700 border border-gray-600 focus:border-green-500 focus:ring-2 focus:ring-green-500/20 transition-all"
                  />
                </div>
              )}

              {/* Answer Textarea - Long Answer */}
              {currentQuestion.questionType === 'LONG_ANSWER' && (
                <div>
                  <label className="block text-sm font-medium text-gray-400 mb-2">
                    Your Answer
                  </label>
                  <textarea
                    value={currentAnswer?.answer || ''}
                    onChange={(e) => handleAnswerChange(currentQuestion.questionId, e.target.value)}
                    placeholder="Type your detailed answer here..."
                    rows={8}
                    className="w-full px-4 py-3 rounded-xl bg-gray-700 border border-gray-600 focus:border-green-500 focus:ring-2 focus:ring-green-500/20 transition-all resize-none"
                  />
                </div>
              )}
            </div>

            {/* Navigation */}
            <div className="flex items-center justify-between mt-6">
              <button
                onClick={handlePreviousQuestion}
                disabled={currentQuestionIndex === 0}
                className="px-6 py-3 rounded-xl bg-gray-700 hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed transition-all flex items-center gap-2"
              >
                <ChevronLeft className="w-5 h-5" />
                Previous
              </button>

              <button
                onClick={() => handleAnswerChange(currentQuestion.questionId, currentAnswer?.answer || '')}
                className="px-6 py-3 rounded-xl bg-blue-600 hover:bg-blue-700 transition-all flex items-center gap-2"
              >
                <Save className="w-4 h-4" />
                Save Answer
              </button>

              <button
                onClick={handleNextQuestion}
                disabled={currentQuestionIndex === exam.questions.length - 1}
                className="px-6 py-3 rounded-xl bg-gray-700 hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed transition-all flex items-center gap-2"
              >
                Next
                <ChevronRight className="w-5 h-5" />
              </button>
            </div>
          </div>
        </div>

        {/* Sidebar - Question Navigator */}
        <div className="w-80 bg-gray-800 border-l border-gray-700 overflow-y-auto p-6">
          {/* Stats */}
          <div className="grid grid-cols-2 gap-3 mb-6">
            <div className="p-3 rounded-xl bg-green-900/20 border border-green-800">
              <p className="text-xs text-green-400 mb-1">Answered</p>
              <p className="text-2xl font-bold text-green-400">{answeredCount}</p>
            </div>
            <div className="p-3 rounded-xl bg-orange-900/20 border border-orange-800">
              <p className="text-xs text-orange-400 mb-1">Flagged</p>
              <p className="text-2xl font-bold text-orange-400">{flaggedCount}</p>
            </div>
          </div>

          {/* Question Grid */}
          <div>
            <h3 className="text-sm font-semibold text-gray-400 mb-3">Questions</h3>
            <div className="grid grid-cols-5 gap-2">
              {exam.questions.map((q: any, index: number) => {
                const answer = answers.get(q.questionId || '');
                const isAnswered = !!answer?.answer;
                const isFlagged = answer?.flagged;
                const isCurrent = index === currentQuestionIndex;

                return (
                  <button
                    key={index}
                    onClick={() => handleJumpToQuestion(index)}
                    className={`aspect-square rounded-lg font-semibold transition-all relative ${
                      isCurrent
                        ? 'bg-green-600 text-white ring-2 ring-green-400'
                        : isAnswered
                        ? 'bg-green-900/30 text-green-400 border border-green-800'
                        : 'bg-gray-700 text-gray-400 border border-gray-600 hover:border-gray-500'
                    }`}
                  >
                    {index + 1}
                    {isFlagged && (
                      <Flag
                        className="w-3 h-3 absolute top-0.5 right-0.5 text-orange-400"
                        fill="currentColor"
                      />
                    )}
                  </button>
                );
              })}
            </div>
          </div>

          {/* Proctoring Status - Hide for practice exams */}
          {exam && !((exam as any)['Is Practice'] === 'Yes' || (exam as any).isPractice === true) && (
            <>
              <div className="mt-6 p-4 rounded-xl bg-gray-700">
                <h3 className="text-sm font-semibold mb-3">Proctoring Status</h3>
                <div className="space-y-2 text-sm">
                  <div className="flex items-center justify-between">
                    <span className="text-gray-400">Webcam</span>
                    {webcamActive ? (
                      <CheckCircle className="w-4 h-4 text-green-400" />
                    ) : (
                      <XCircle className="w-4 h-4 text-red-400" />
                    )}
                  </div>
                  <div className="flex items-center justify-between">
                    <span className="text-gray-400">Screen Share</span>
                    {screenShareActive ? (
                      <CheckCircle className="w-4 h-4 text-green-400" />
                    ) : (
                      <XCircle className="w-4 h-4 text-red-400" />
                    )}
                  </div>
                  <div className="flex items-center justify-between">
                    <span className="text-gray-400">Violations</span>
                    <span className={violationCount > 0 ? 'text-red-400 font-semibold' : 'text-green-400'}>
                      {violationCount}
                    </span>
                  </div>
                </div>
              </div>

              {/* Webcam Preview */}
              {webcamActive && (
                <div className="mt-4">
                  <h3 className="text-sm font-semibold text-gray-400 mb-2">Webcam Preview</h3>
                  <div className="relative rounded-lg overflow-hidden bg-gray-700">
                    <video
                      ref={videoRef}
                      autoPlay
                      muted
                      playsInline
                      className="w-full h-auto"
                    />
                    <div className="absolute top-2 right-2 w-3 h-3 rounded-full bg-red-500 animate-pulse" />
                  </div>
                </div>
              )}
            </>
          )}
        </div>
      </div>

      {/* Violation Warning */}
      {showWarning && (
        <div className="fixed top-20 left-1/2 transform -translate-x-1/2 z-50 animate-bounce">
          <div className="bg-red-600 text-white px-6 py-4 rounded-xl shadow-2xl flex items-center gap-3 max-w-md">
            <AlertTriangle className="w-6 h-6 flex-shrink-0" />
            <p className="font-semibold">{warningMessage}</p>
          </div>
        </div>
      )}

      {/* Submit Confirmation Modal */}
      {showSubmitConfirm && (
        <div className="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50 p-4">
          <div className="bg-gray-800 rounded-2xl max-w-md w-full p-6 border border-gray-700">
            <h3 className="text-xl font-bold mb-2">Submit Exam?</h3>
            <p className="text-gray-400 mb-6">
              Are you sure you want to submit? You have answered {answeredCount} out of {exam.questions.length} questions.
            </p>
            <div className="flex gap-3">
              <button
                onClick={() => setShowSubmitConfirm(false)}
                className="flex-1 px-4 py-3 rounded-xl border border-gray-600 hover:bg-gray-700 transition-all"
              >
                Cancel
              </button>
              <button
                onClick={() => {
                  setShowSubmitConfirm(false);
                  handleSubmit(true);
                }}
                className="flex-1 px-4 py-3 rounded-xl bg-green-600 hover:bg-green-700 font-semibold transition-all"
              >
                Submit Exam
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default ExamAttempt;
